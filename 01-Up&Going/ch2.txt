Chapter 2: Into JavaScript

Built-in types: string, number, boolean, null (is an object) and undefined, 
                object and symbol(ES6 only)

JavaScript proves typeof operator to show what type a variable is

Objects can be accessed with obj.a or obj["a"]

Subtypes: specialized versions of the object type, such as array(typeof returns
          an object) and function

E.g.
    a = [];
    a.bar = "foo";
    a[0] = 5;
    //a becomes [5, bar: "foo"] and "foo" can only be accessed with calling a.bar

Properties can be added to functions since they are a subtype of objects

Built-In Type Methods:
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"

Coercion:
  -explicit coercion is simply seeing from the code that conversion from one type
   to another will occur
  -implicit coercion is when the type conversion can happen as more of a non-obvious
   side-effect
    e.g.
      var a = "42";
      var b = a * 1;	// "42" implicitly coerced to 42 here
      a;				// "42"
      b;				// 42 -- the number!
      
== checks for value equality with coercion allowed and === checks for value equality
without coercion allowed (value and type)

e.g.
  var a = "42";
  var b = 42;

  a == b;			// true
  a === b;		// false
  
If comparing two non-primitive types like objects including function and array,
since these values are held by reference, both == and === comparison will simply
check whether the references match, not anything about the underlying values

e.g.
  var a = [1,2,3];
  var b = [1,2,3];
  var c = "1,2,3";

  a == c;		// true
  b == c;		// true
  a == b;		// false
  // array a and b have two different reference therefore false
  /* arrays by default get coerced to string by simply joining all values with
     ',' in between
     
If both values in the < comparison are strings, as it is with b < c, the comparison
is made lexicographically (aka alphabetically like a dictionary), but if one or both
is not a string then both values are coerced to be numbers, and a typical numeric
comparison occurs

NaN is neither greater-than nor less-than any other value

