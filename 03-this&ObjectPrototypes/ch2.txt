Chapter 2: 'this' All Makes Sense Now
-again, 'this' is a binding made for each function invocation, based entirely on
 its call-site (how the function is called)

Call-site:
-call-site: where a function is called (not where it's declared)
-call-site is not always locating where a function is called from since certain
 coding patterns can obscure the true call-site
-the call-stack (the stack of functions that have been called to get us to the
 current moment in execution)
-so, call-site is in the invocation before the currently executing function
E.g.
function baz() {
    // call-stack is: `baz`
    // so, our call-site is in the global scope

    console.log( "baz" );
    bar(); // <-- call-site for `bar`
}

function bar() {
    // call-stack is: `baz` -> `bar`
    // so, our call-site is in `baz`

    console.log( "bar" );
    foo(); // <-- call-site for `foo`
}

function foo() {
    // call-stack is: `baz` -> `bar` -> `foo`
    // so, our call-site is in `bar`

    console.log( "foo" );
}

baz(); // <-- call-site for `baz`

-can use JS debugger to put a breakpoint or simply insert 'debugger' statement

Nothing But Rules:
  Default Binding:
    -standalone function invocation, think of it as the default catch-all rule
     when none of the other rules apply
    E.g.
    function foo() {
    	console.log( this.a );
    }
    var a = 2;
    foo(); // 2
    
    -variables declared in the global scope are synonymous with global-object
     properties of the same name, they're each other, 2 sides of the same coin
    -in this case, default binding for 'this' applies to the function call, so
     'this' points at the global object
    -if 'strict mode', global object is not eligible for the default binding, so
     'this' is instead set to undefined, the 'strict mode' state of the call-site
     of foo() is irrelevant
     
    E.g.
    function foo() {
    	"use strict";
    	console.log( this.a );
    }
    var a = 2;
    foo(); // TypeError: `this` is `undefined`
    
  -entire program should either be Strict or non-Strict and mixing is frowned upon

  Implicit Binding:
    -does the call-site have a context object?
    E.g.
    function foo() {
    	console.log( this.a );
    }

    var obj = {
    	a: 2,
    	foo: foo
    };

    obj.foo(); // 2
    
    -the function is not "owned" or "contained" by the 'obj' object
    -but, the call-site uses the 'obj' context to reference the function, so one
     could say the 'obj' "owns" or "contains" the function reference at the time
     the function is called
    
    
    